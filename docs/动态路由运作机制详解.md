# 动态路由运作机制详解

## 🎯 动态路由架构概述

动态路由是我们Flink实时计算架构的核心特性，支持在运行时动态更新路由配置，无需重启作业即可支持新的事件类型和处理逻辑。

## 🏗️ 核心组件架构

```
                        MySQL配置表
                   (flink_routing_config)
                            │
                            ▼
              ┌─────────────────────────────┐
              │  DynamicRoutingConfigSource  │
              │  - 30秒定时轮询配置表         │
              │  - 检测配置变化并广播         │
              │  - 支持增量更新              │
              └─────────────┬───────────────┘
                            │ 广播流
                            ▼
┌───────────────┐  ┌─────────────────────────────┐
│   Kafka事件源  │─→│ DynamicRoutingProcessFunction │
│ (BusinessEvent)│  │  - 接收配置广播流            │
│               │  │  - 维护路由状态缓存          │
│               │  │  - 动态创建事件处理器        │
│               │  │  - 二级路由匹配             │
└───────────────┘  └─────────────┬───────────────┘
                                  │ ProcessedEvent
                                  ▼
                    ┌─────────────────────────────┐
                    │ OutputRoutingProcessFunction │
                    │  - 多路输出分流              │
                    │  - MySQL/Kafka双输出支持     │
                    │  - 侧流处理（告警/指标）      │
                    └─────────────────────────────┘
```

## 🔄 路由工作流程

### 1. 配置管理阶段

#### 配置表结构
```sql
CREATE TABLE flink_routing_config (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    domain VARCHAR(50) NOT NULL COMMENT '业务域（如wrongbook）',
    event_type VARCHAR(100) NOT NULL COMMENT '事件类型（如wrongbook_add）',
    processor_class VARCHAR(200) NOT NULL COMMENT '处理器类名',
    output_config JSON COMMENT '输出配置（支持MySQL/Kafka双输出）',
    is_enabled BOOLEAN DEFAULT TRUE COMMENT '是否启用',
    priority INT DEFAULT 100 COMMENT '优先级',
    create_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    update_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    UNIQUE KEY uk_domain_type (domain, event_type)
);
```

#### 示例配置数据
```sql
-- 错题添加事件配置（MySQL输出）
INSERT INTO flink_routing_config (domain, event_type, processor_class, output_config) 
VALUES ('wrongbook', 'wrongbook_add', 
        'com.flink.realtime.topics.wrongbook.processor.WrongbookAddProcessor',
        '{"sinks": ["mysql", "wide_table"]}');

-- 错题订正事件配置（双输出：MySQL + Kafka）
INSERT INTO flink_routing_config (domain, event_type, processor_class, output_config)
VALUES ('wrongbook', 'wrongbook_fix',
        'com.flink.realtime.topics.wrongbook.processor.WrongbookFixProcessor', 
        '{"sinks": ["mysql", "kafka", "downstream_topic"]}');
```

### 2. 配置广播阶段

#### DynamicRoutingConfigSource工作机制
```java
// 1. 初始化阶段：加载所有配置
private void loadAllConfigs(SourceContext<RoutingConfig> ctx) {
    String sql = "SELECT * FROM flink_routing_config WHERE domain = ? ORDER BY priority DESC";
    // 执行查询并广播所有配置到下游
}

// 2. 定时检查阶段：每30秒检查更新
private void checkConfigUpdates(SourceContext<RoutingConfig> ctx) {
    String sql = "SELECT * FROM flink_routing_config WHERE domain = ? AND update_time > ?";
    // 只查询有更新的配置，减少网络传输
}
```

#### 配置更新的触发机制
- **定时检查**：每30秒查询一次配置表
- **增量更新**：只传输有变化的配置项
- **版本控制**：基于update_time字段判断是否有更新
- **异常恢复**：配置查询失败时自动重试

### 3. 事件路由阶段

#### 二级路由匹配
```java
// 路由键格式：domain:type（二级路由）
String routingKey = event.getDomain() + ":" + event.getType();
// 例如：wrongbook:wrongbook_add
```

#### 路由决策流程
```java
// 1. 从广播状态获取路由配置
RoutingConfig config = configState.get(routingKey);

// 2. 检查配置有效性
if (config == null || !config.isEnabled()) {
    // 记录失败指标，事件进入死信队列
    return;
}

// 3. 获取或创建处理器
EventProcessor processor = getOrCreateProcessor(config.getProcessorClass());

// 4. 执行业务处理
Object result = processor.process(event);

// 5. 构造输出事件
ProcessedEvent processedEvent = new ProcessedEvent(event, result, config.getOutputConfig());
```

### 4. 处理器管理阶段

#### 处理器创建和缓存
```java
private final Map<String, EventProcessor> processorCache = new ConcurrentHashMap<>();

private EventProcessor getOrCreateProcessor(String processorClass) {
    return processorCache.computeIfAbsent(processorClass, className -> {
        try {
            // 动态加载处理器类
            Class<?> clazz = Class.forName(className);
            EventProcessor processor = (EventProcessor) clazz.newInstance();
            logger.info("创建新处理器实例: {}", className);
            return processor;
        } catch (Exception e) {
            logger.error("创建处理器失败: {}", className, e);
            return null;
        }
    });
}
```

#### 处理器热更新机制
- **配置更新时清理缓存**：确保使用最新的处理器
- **类加载隔离**：支持处理器版本升级
- **异常隔离**：单个处理器异常不影响其他处理器

### 5. 输出路由阶段

#### 多输出目标支持
```java
// 根据输出配置决定数据去向
if (config.getOutputConfig() != null) {
    Object sinks = config.getOutputConfig().get("sinks");
    if (sinks instanceof List) {
        processedEvent.setOutputTargets((List<String>) sinks);
    }
}
```

#### 输出目标类型
- **mysql/wide_table**: 写入MySQL宽表
- **kafka/downstream_topic**: 写入Kafka下游topic
- **alert_topic**: 写入告警流
- **metrics_topic**: 写入指标流
- **audit_topic**: 写入审计流

## 🎛️ 配置管理操作

### 运行时配置管理
```bash
# 查看当前路由配置
java -cp flink-job.jar com.flink.realtime.config.RoutingConfigManager list wrongbook

# 添加新的路由配置
java -cp flink-job.jar com.flink.realtime.config.RoutingConfigManager add \
  wrongbook wrongbook_delete \
  com.flink.realtime.topics.wrongbook.processor.WrongbookDeleteProcessor

# 启用/禁用路由配置
java -cp flink-job.jar com.flink.realtime.config.RoutingConfigManager enable wrongbook wrongbook_add
java -cp flink-job.jar com.flink.realtime.config.RoutingConfigManager disable wrongbook wrongbook_add

# 删除路由配置
java -cp flink-job.jar com.flink.realtime.config.RoutingConfigManager delete wrongbook wrongbook_add
```

### SQL方式配置管理
```sql
-- 新增路由配置
INSERT INTO flink_routing_config (domain, event_type, processor_class, output_config, is_enabled)
VALUES ('wrongbook', 'wrongbook_batch_import', 
        'com.flink.realtime.topics.wrongbook.processor.WrongbookBatchImportProcessor',
        '{"sinks": ["mysql", "kafka"]}', true);

-- 修改输出配置（支持双输出）
UPDATE flink_routing_config 
SET output_config = '{"sinks": ["mysql", "kafka", "downstream_topic"]}',
    update_time = CURRENT_TIMESTAMP
WHERE domain = 'wrongbook' AND event_type = 'wrongbook_add';

-- 禁用某个路由
UPDATE flink_routing_config 
SET is_enabled = false, 
    update_time = CURRENT_TIMESTAMP
WHERE domain = 'wrongbook' AND event_type = 'wrongbook_delete';
```

## 📊 监控和运维

### 关键指标监控
- **配置加载成功率**: 配置更新的成功比例
- **路由匹配率**: 事件成功路由的比例
- **处理器缓存命中率**: 处理器缓存的效率
- **处理延迟**: 端到端的处理延迟
- **异常率**: 处理失败的事件比例

### 故障排查
```java
// 1. 检查路由配置是否存在
SELECT * FROM flink_routing_config WHERE domain = 'wrongbook' AND event_type = 'wrongbook_add';

// 2. 检查处理器类是否可加载
try {
    Class<?> clazz = Class.forName("com.flink.realtime.topics.wrongbook.processor.WrongbookAddProcessor");
    EventProcessor processor = (EventProcessor) clazz.newInstance();
} catch (Exception e) {
    // 处理器类加载失败
}

// 3. 检查事件格式是否正确
{
  "domain": "wrongbook",
  "type": "wrongbook_add", 
  "eventId": "uuid",
  "timestamp": 1640995200000,
  "payload": { /* 业务数据 */ }
}
```

## 🚀 性能优化

### 配置查询优化
- **增量查询**: 只查询有更新的配置
- **连接池**: 使用连接池管理数据库连接
- **缓存策略**: 本地缓存配置减少数据库查询

### 处理器管理优化
- **延迟加载**: 只在需要时创建处理器实例
- **缓存策略**: 合理设置处理器缓存大小
- **内存管理**: 及时清理无用的处理器实例

### 路由性能优化
- **哈希查找**: 使用HashMap实现O(1)路由查找
- **批量处理**: 支持批量事件处理
- **异步处理**: 维表查询使用异步调用

## 🔧 扩展性设计

### 支持新业务域
1. 在配置表中添加新的domain
2. 创建对应的处理器类
3. 配置路由规则
4. 无需重启作业

### 支持新事件类型
1. 在现有domain下添加新的event_type
2. 实现对应的EventProcessor
3. 更新路由配置
4. 30秒内自动生效

### 支持新输出目标
1. 扩展output_config配置
2. 在OutputRoutingProcessFunction中添加新的输出逻辑
3. 配置对应的Sink
4. 支持运行时动态调整

---

**动态路由机制的核心价值在于：零停机时间的配置更新、快速响应业务变化、统一的事件处理框架！** 🎉
