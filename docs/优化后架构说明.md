# 优化后的Flink实时计算架构说明

## 🎯 架构优化概述

经过深度优化，我们的Flink架构现在采用**职责分离设计**，实现了更好的模块化和可维护性。

## 🏗️ 核心设计理念

### 📋 职责分工
```
CommonWideTableApp (入口类)
    ↓ 只负责路由发现和type转发
    
EventProcessor (处理器)
    ↓ 负责业务逻辑 + 输出决策 + 数据输出
    
UnifiedSinkService (输出服务)
    ↓ 提供统一的MySQL和Kafka输出封装
```

### 🎯 设计优势
- ✅ **单一职责**：每个组件职责清晰，易于维护
- ✅ **高度复用**：所有topic使用同一个入口
- ✅ **灵活输出**：每个processor自主决定输出策略
- ✅ **配置简化**：只需配置topic:type → processor的映射

## 📊 优化后的架构图

```
Kafka事件源                     MySQL路由配置           维表数据
(topic-events)                 (简化配置表)           (缓存查询)
      │                            │                     │
      ▼                            ▼                     ▼
┌─────────────────────────────────────────────────────────────┐
│                CommonWideTableApp                           │
│                   (统一入口)                                │
│                                                             │
│  1. 解析事件 domain:type (二级路由)                          │
│  2. 路由键匹配: wrongbook:wrongbook_add                      │
│  3. 转发到对应处理器                                        │
│                                                             │
└─────────────┬───────────────────────────────────────────────┘
              │ BusinessEvent
              ▼
┌─────────────────────────────────────────────────────────────┐
│                  EventProcessor                             │
│                (业务处理器)                                  │
│                                                             │
│  1. 业务逻辑处理                                            │
│  2. 维表查询 (DimTableQueryService)                         │
│  3. 输出决策 (根据业务规则)                                  │
│  4. 数据输出 (UnifiedSinkService)                           │
│                                                             │
└─────────────┬───────────────────────────────────────────────┘
              │ 自主输出
              ▼
┌─────────────────────────────────────────────────────────────┐
│                UnifiedSinkService                           │
│                 (统一输出服务)                               │
│                                                             │
│  ┌─────────────────┐              ┌─────────────────┐       │
│  │   MySQL输出      │              │   Kafka输出      │       │
│  │ - 连接池管理      │              │ - 序列化封装     │       │
│  │ - 批量写入       │              │ - 认证支持       │       │
│  │ - 错误重试       │              │ - 分区策略       │       │
│  └─────────────────┘              └─────────────────┘       │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## 🔧 核心组件详解

### 1. CommonWideTableApp - 统一入口
```java
// 超级简化的使用方式
public static void main(String[] args) throws Exception {
    CommonWideTableApp.execute("wrongbook");
}
```

**职责**：
- ✅ 路由发现和事件转发
- ✅ 环境配置和作业启动
- ❌ 不再负责Sink配置
- ❌ 不再处理输出逻辑

### 2. EventProcessor - 业务处理器
```java
@ProcessorConfig(eventTypes = {"wrongbook:wrongbook_add"})
public class WrongbookAddProcessor implements EventProcessor {
    
    @Override
    public void process(BusinessEvent event, Collector<ProcessedEvent> collector) {
        // 1. 业务逻辑处理
        // 2. 维表查询
        // 3. 输出决策
        // 4. 数据输出
    }
}
```

**职责**：
- ✅ 业务逻辑处理
- ✅ 维表查询和数据丰富
- ✅ 输出目标决策
- ✅ 数据输出执行

### 3. UnifiedSinkService - 统一输出服务
```java
UnifiedSinkService sinkService = UnifiedSinkService.getInstance();

// MySQL输出
sinkService.createMySQLSink("table_name", sqlBuilder);

// Kafka输出
sinkService.createKafkaSink("topic_name");
```

**功能**：
- ✅ MySQL和Kafka输出封装
- ✅ 连接池和性能优化
- ✅ 错误处理和重试机制
- ✅ 配置管理和缓存

## 📋 配置简化

### 路由配置表 (简化版)
```sql
CREATE TABLE flink_routing_config (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    domain VARCHAR(50) NOT NULL COMMENT '业务域',
    event_type VARCHAR(100) NOT NULL COMMENT '事件类型',
    processor_class VARCHAR(200) NOT NULL COMMENT '处理器类名',
    is_enabled BOOLEAN DEFAULT TRUE COMMENT '是否启用',
    priority INT DEFAULT 100 COMMENT '优先级',
    create_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    update_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    UNIQUE KEY uk_domain_type (domain, event_type)
);
```

### 配置示例
```sql
-- 错题添加事件（简化配置）
INSERT INTO flink_routing_config (domain, event_type, processor_class) 
VALUES ('wrongbook', 'wrongbook_add', 
        'com.flink.realtime.topics.wrongbook.processor.WrongbookAddProcessor');

-- 错题订正事件
INSERT INTO flink_routing_config (domain, event_type, processor_class)
VALUES ('wrongbook', 'wrongbook_fix',
        'com.flink.realtime.topics.wrongbook.processor.WrongbookFixProcessor');
```

**简化点**：
- ❌ 不再需要复杂的output_config配置
- ❌ 不再需要sinks数组配置
- ✅ 只需要简单的路由映射

## 🚀 使用流程

### 1. 新增业务Topic
```java
// 1. 创建App类（极简）
public class UserWideTableApp {
    public static void main(String[] args) throws Exception {
        CommonWideTableApp.execute("user");
    }
}

// 2. 实现处理器
@ProcessorConfig(eventTypes = {"user:user_register"})
public class UserRegisterProcessor implements EventProcessor {
    // 业务逻辑 + 输出决策
}

// 3. 配置路由
INSERT INTO flink_routing_config (domain, event_type, processor_class)
VALUES ('user', 'user_register', 'com.flink.realtime.topics.user.processor.UserRegisterProcessor');
```

### 2. 处理器开发模式
```java
@ProcessorConfig(eventTypes = {"wrongbook:wrongbook_add"})
public class WrongbookAddProcessor implements EventProcessor {
    
    private final DimTableQueryService dimService = DimTableQueryService.getInstance();
    private final UnifiedSinkService sinkService = UnifiedSinkService.getInstance();
    
    @Override
    public void process(BusinessEvent event, Collector<ProcessedEvent> collector) {
        // 1. 解析payload
        WrongbookAddPayload payload = parsePayload(event);
        
        // 2. 查询维表
        enrichWithDimensions(payload);
        
        // 3. 构建宽表数据
        Map<String, Object> wideTableData = buildWideTableData(payload);
        
        // 4. 决定输出目标
        if (shouldOutputToMySQL(payload)) {
            outputToMySQL(wideTableData);
        }
        
        if (shouldOutputToKafka(payload)) {
            outputToKafka(wideTableData);
        }
        
        // 5. 收集监控事件
        collector.collect(new ProcessedEvent(event, wideTableData, null));
    }
}
```

## 📈 性能优化

### 1. 连接池管理
- **MySQL连接池**：复用数据库连接
- **Kafka生产者池**：复用Kafka连接
- **维表查询缓存**：30分钟TTL缓存

### 2. 批量处理
- **MySQL批量写入**：1000条/批或5秒间隔
- **Kafka批量发送**：自动批量优化
- **维表批量查询**：IN查询支持

### 3. 错误处理
- **自动重试机制**：3次重试
- **死信队列**：处理失败事件
- **监控指标**：完整的性能监控

## 🔍 监控和运维

### 关键指标
- **处理器性能**：各processor的处理延迟和吞吐量
- **输出成功率**：MySQL/Kafka输出成功率
- **维表查询性能**：缓存命中率和查询延迟
- **错误率统计**：各类异常的分类统计

### 运维操作
```sql
-- 查看处理器状态
SELECT domain, event_type, processor_class, is_enabled 
FROM flink_routing_config 
WHERE domain = 'wrongbook';

-- 禁用某个处理器
UPDATE flink_routing_config 
SET is_enabled = false 
WHERE domain = 'wrongbook' AND event_type = 'wrongbook_add';

-- 查看缓存统计
-- 通过JMX或日志查看DimTableQueryService缓存状态
```

## 🎉 架构优势总结

### ✅ 开发效率提升
- **新增topic**: 只需1个App类（3行代码）+ N个处理器
- **配置简化**: 只需配置简单的路由映射
- **代码复用**: 高度复用通用组件

### ✅ 运维便利性
- **统一入口**: 所有作业使用相同的入口模式
- **配置集中**: 路由配置集中管理
- **监控统一**: 统一的监控和指标体系

### ✅ 性能优化
- **连接复用**: 数据库和Kafka连接池
- **缓存优化**: 维表查询缓存
- **批量处理**: 高效的批量写入

### ✅ 扩展性保证
- **处理器独立**: 各processor独立开发和部署
- **输出灵活**: 每个processor自主决定输出策略
- **配置热更新**: 30秒内配置变更生效

**这个优化后的架构实现了真正的模块化、高性能和易维护！** 🚀
