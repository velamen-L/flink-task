plugins {
    id 'java'
    id 'maven-publish'
}

group = 'com.flink.realtime'
version = '1.0.0'

java {
    sourceCompatibility = JavaVersion.VERSION_17
    targetCompatibility = JavaVersion.VERSION_17
}

repositories {
    mavenCentral()
    maven {
        url 'https://repo1.maven.org/maven2'
    }
}

dependencies {
    // Flink dependencies
    implementation 'org.apache.flink:flink-streaming-java:1.18.0'
    implementation 'org.apache.flink:flink-table-api-java-bridge:1.18.0'
    implementation 'org.apache.flink:flink-table-runtime:1.18.0'
    implementation 'org.apache.flink:flink-clients:1.18.0'
    
    // Connector dependencies
    implementation 'org.apache.flink:flink-connector-kafka:1.18.0'
    implementation 'org.apache.flink:flink-connector-jdbc:3.1.1-1.18'
    implementation 'mysql:mysql-connector-java:8.0.33'
    
    // JSON processing
    implementation 'com.fasterxml.jackson.core:jackson-databind:2.15.2'
    implementation 'com.fasterxml.jackson.dataformat:jackson-dataformat-yaml:2.15.2'
    
    // Logging
    implementation 'org.slf4j:slf4j-api:1.7.36'
    implementation 'org.apache.logging.log4j:log4j-slf4j-impl:2.20.0'
    
    // Test dependencies
    testImplementation 'junit:junit:4.13.2'
    testImplementation 'org.apache.flink:flink-test-utils:1.18.0'
}

// =============================================================================
// 极简版Flink SQL
// =============================================================================

// 极简版AI工作流配置
ext.ultraSimpleSqlConfig = [
    workspaceDir: 'job',
    aiProvider: 'cursor',
    rulesFile: '.cursor/rules/ultra-simple-sql-generator.mdc',
    requestFileName: 'request.md',
    outputSqlDir: 'sql',
    outputTestDir: 'test',
    outputDocsDir: 'docs',
    templateFile: 'job/ultra-simple-request-template.md',
    cursorCliPath: '/Applications/Cursor.app/Contents/Resources/app/bin/cursor',
    cursorAgentPath: 'cursor-agent'  // 新的Cursor Agent CLI (Beta)
]

// Flink SQL任务组
def FLINK_SQL_TASK_GROUP = 'flink-sql-generator'

// 1. 主任务: 极简版Flink SQL生成 (自动复制到剪贴板)
task generateSql {
    group FLINK_SQL_TASK_GROUP
    description '基于极简版request.md文件智能生成Flink SQL和测试数据，自动复制提示词到剪贴板'
    
    doLast {
        def requestPath = project.findProperty('file') ?: ''
        
        if (!requestPath) {
            println """
            ❌ 错误: 未指定request文件路径
            
            使用方法:
            gradle generateSql -Pfile=job/wrongbook/request.md
            gradle generateSql -Pfile=job/user-stats/request.md
            """
            throw new GradleException("必须指定request文件路径")
        }
        
        def requestFile = file(requestPath)
        if (!requestFile.exists()) {
            println "❌ 错误: 文件不存在: ${requestPath}"
            throw new GradleException("Request文件不存在")
        }
        
        def domainPath = requestFile.parent
        def domainName = new File(domainPath).name
        
        println """
        🚀 极简版Flink SQL生成器
        
        📁 业务域: ${domainName}
        📄 输入文件: ${requestPath}
        🔧 规则文件: ${ultraSimpleSqlConfig.rulesFile}
        📤 输出目录: ${domainPath}
        
        请在Cursor中使用以下提示词：
        ================================================
        请基于 ultra-simple-sql-generator.mdc 规则，
        处理 ${requestPath} 文件，
        生成完整的Flink SQL和测试数据。

        输出要求：
        1. SQL文件: ${domainPath}/${ultraSimpleSqlConfig.outputSqlDir}/${domainName}_ultra.sql
        2. 测试数据: ${domainPath}/${ultraSimpleSqlConfig.outputTestDir}/kafka-test-data.md
        ================================================
        """
        
        // 创建输出目录结构
        [
            "${domainPath}/${ultraSimpleSqlConfig.outputSqlDir}",
            "${domainPath}/${ultraSimpleSqlConfig.outputTestDir}",
            "${domainPath}/${ultraSimpleSqlConfig.outputDocsDir}"
        ].each { dir ->
            mkdir dir
        }
        
        // 尝试自动在Cursor中执行AI生成
        def promptText = """请基于 ultra-simple-sql-generator.mdc 规则，
处理 ${requestPath} 文件，
生成完整的Flink SQL和测试数据。

输出要求：
1. SQL文件: ${domainPath}/${ultraSimpleSqlConfig.outputSqlDir}/${domainName}_ultra.sql
2. 测试数据: ${domainPath}/${ultraSimpleSqlConfig.outputTestDir}/kafka-test-data.md"""

        // 方法1: 尝试通过cursor命令行工具执行
        try {
            def cursorCommand = ["cursor", "--prompt", promptText]
            def process = new ProcessBuilder(cursorCommand)
                .directory(file('.'))
                .start()
            
            if (process.waitFor() == 0) {
                println "✅ 已自动在Cursor中执行AI生成任务！"
                return
            }
        } catch (Exception e) {
            // cursor命令不可用，继续尝试其他方法
        }
        
        // 方法2: 尝试复制提示词到剪贴板
        try {
            def clipboardCommand
            def osName = System.getProperty("os.name").toLowerCase()
            if (osName.contains("mac")) {
                clipboardCommand = ["pbcopy"]
            } else if (osName.contains("windows")) {
                clipboardCommand = ["clip"]
            } else {
                clipboardCommand = ["xclip", "-selection", "clipboard"]
            }
            
            def process = new ProcessBuilder(clipboardCommand)
                .start()
            process.outputStream.write(promptText.bytes)
            process.outputStream.close()
            
            if (process.waitFor() == 0) {
                println """
                ✅ 输出目录创建完成！
                📋 提示词已复制到剪贴板，请在Cursor中粘贴执行
                
                💡 提示: 在Cursor中按 Ctrl+V (或 Cmd+V) 粘贴提示词
                """
                return
            }
        } catch (Exception e) {
            // 剪贴板复制失败，使用默认方式
        }
        
        // 方法3: 默认显示提示词
        println """
        ✅ 输出目录创建完成！
        📋 请在Cursor中使用以下提示词执行生成任务：
        
        ${promptText}
        
        💡 提示: 复制上述提示词到Cursor AI聊天窗口执行
        """
    }
}

// 1.1. 高级任务: 智能Cursor集成 (自动打开+剪贴板)
task generateSqlAuto {
    group FLINK_SQL_TASK_GROUP
    description '使用Cursor CLI智能集成：自动打开项目+复制提示词到剪贴板'
    
    doLast {
        def requestPath = project.findProperty('file') ?: ''
        
        if (!requestPath) {
            println """
            ❌ 错误: 未指定request文件路径
            
            使用方法:
            gradle generateSqlAuto -Pfile=job/wrongbook/request.md
            """
            throw new GradleException("必须指定request文件路径")
        }
        
        def requestFile = file(requestPath)
        if (!requestFile.exists()) {
            println "❌ 错误: 文件不存在: ${requestPath}"
            throw new GradleException("Request文件不存在")
        }
        
        def domainPath = requestFile.parent
        def domainName = new File(domainPath).name
        
        // 创建输出目录结构
        [
            "${domainPath}/${ultraSimpleSqlConfig.outputSqlDir}",
            "${domainPath}/${ultraSimpleSqlConfig.outputTestDir}",
            "${domainPath}/${ultraSimpleSqlConfig.outputDocsDir}"
        ].each { dir ->
            mkdir dir
        }
        
        def promptText = """请基于 ultra-simple-sql-generator.mdc 规则，处理 ${requestPath} 文件，生成完整的Flink SQL和测试数据。

输出要求：
1. SQL文件: ${domainPath}/${ultraSimpleSqlConfig.outputSqlDir}/${domainName}_ultra.sql
2. 测试数据: ${domainPath}/${ultraSimpleSqlConfig.outputTestDir}/kafka-test-data.md"""

        println """
        🚀 自动Cursor集成模式
        
        📁 业务域: ${domainName}
        📄 输入文件: ${requestPath}
        🤖 尝试自动集成...
        """
        
        // 方法1: 使用Cursor CLI智能集成 (无需特殊权限)
        try {
            def cursorCliPath = ultraSimpleSqlConfig.cursorCliPath
            def cursorCli = file(cursorCliPath)
            
            if (cursorCli.exists()) {
                println "🚀 正在启动Cursor并准备AI提示词..."
                
                // 1. 将提示词复制到剪贴板
                def clipboardProcess = new ProcessBuilder(["pbcopy"]).start()
                clipboardProcess.outputStream.write(promptText.bytes)
                clipboardProcess.outputStream.close()
                clipboardProcess.waitFor()
                
                // 2. 使用Cursor CLI打开项目（会激活Cursor窗口）
                def cursorProcess = new ProcessBuilder([cursorCliPath, "."]).start()
                cursorProcess.waitFor()
                
                println """
                ✅ Cursor CLI智能集成完成！
                
                📋 提示词已复制到剪贴板
                🖥️ Cursor已自动激活并打开项目
                
                💡 最后两步 (只需3秒):
                1️⃣ 按 Cmd+Shift+K 打开AI聊天
                2️⃣ 按 Cmd+V 粘贴提示词，然后按回车发送
                
                📄 生成完成后，文件将自动保存到:
                • SQL文件: ${domainPath}/${ultraSimpleSqlConfig.outputSqlDir}/${domainName}_ultra.sql
                • 测试数据: ${domainPath}/${ultraSimpleSqlConfig.outputTestDir}/kafka-test-data.md
                
                ⏱️ 预计生成时间: 30-60秒
                """
                return
            } else {
                println "⚠️ Cursor CLI不可用，请先运行: gradle setupCursorCli"
            }
        } catch (Exception e) {
            println "⚠️ Cursor CLI集成失败: ${e.message}"
        }
        
        // 方法2: 通过 Cursor CLI 打开项目并复制提示词到剪贴板
        try {
            def cursorCliPath = ultraSimpleSqlConfig.cursorCliPath
            def cursorCli = file(cursorCliPath)
            
            if (cursorCli.exists()) {
                // 先复制提示词到剪贴板
                def clipboardProcess = new ProcessBuilder(["pbcopy"]).start()
                clipboardProcess.outputStream.write(promptText.bytes)
                clipboardProcess.outputStream.close()
                clipboardProcess.waitFor()
                
                // 使用Cursor CLI打开当前项目
                def cursorProcess = new ProcessBuilder([cursorCliPath, "."]).start()
                cursorProcess.waitFor()
                
                println """
                ✅ 已打开Cursor项目并复制提示词到剪贴板！
                
                💡 下一步 (自动化):
                1. 按 Cmd+Shift+K 打开AI聊天
                2. 按 Cmd+V 粘贴提示词
                3. 按 Enter 发送
                
                📄 生成完成后，文件将保存到:
                1. SQL文件: ${domainPath}/${ultraSimpleSqlConfig.outputSqlDir}/${domainName}_ultra.sql
                2. 测试数据: ${domainPath}/${ultraSimpleSqlConfig.outputTestDir}/kafka-test-data.md
                """
                return
            }
        } catch (Exception e) {
            println "⚠️ Cursor CLI执行失败: ${e.message}"
        }
        
        // 方法2: 创建临时文件并尝试用Cursor打开
        try {
            def tempPromptFile = File.createTempFile("cursor_prompt_${domainName}", ".md")
            tempPromptFile.text = """# AI生成任务

${promptText}

---
*此文件由gradle generateSqlAuto自动生成，完成后可删除*
"""
            
            // 尝试用Cursor打开文件
            def openCommand
            def osName = System.getProperty("os.name").toLowerCase()
            if (osName.contains("mac")) {
                openCommand = ["open", "-a", "Cursor", tempPromptFile.absolutePath]
            } else if (osName.contains("windows")) {
                openCommand = ["cursor", tempPromptFile.absolutePath]
            } else {
                openCommand = ["cursor", tempPromptFile.absolutePath]
            }
            
            def process = new ProcessBuilder(openCommand).start()
            if (process.waitFor() == 0) {
                println """
                ✅ 已在Cursor中打开提示词文件！
                📄 文件位置: ${tempPromptFile.absolutePath}
                💡 请在Cursor中复制提示词到AI聊天窗口执行
                """
                return
            }
        } catch (Exception e) {
            println "⚠️ 文件打开失败: ${e.message}"
        }
        
        // 方法3: 回退到剪贴板复制
        try {
            def clipboardCommand = ["pbcopy"]
            def process = new ProcessBuilder(clipboardCommand).start()
            process.outputStream.write(promptText.bytes)
            process.outputStream.close()
            
            if (process.waitFor() == 0) {
                println """
                📋 提示词已复制到剪贴板
                💡 请在Cursor中按 Cmd+V 粘贴并执行
                """
            }
        } catch (Exception e) {
            println """
            ⚠️ 自动化失败，请手动执行以下提示词：
            
            ${promptText}
            """
        }
    }
}

// 1.2. 终极任务: Cursor Agent智能启动 (推荐)
task generateSqlAgent {
    group FLINK_SQL_TASK_GROUP
    description '使用Cursor Agent CLI智能启动并准备提示词 (推荐方案)'
    
    doLast {
        def requestPath = project.findProperty('file') ?: ''
        
        if (!requestPath) {
            println """
            ❌ 请指定request.md文件路径
            💡 用法: gradle generateSqlAgent -Pfile=job/your-domain/request.md
            
            📋 可用文件列表:
            """
            
            def requestFiles = []
            def jobDir = file(ultraSimpleSqlConfig.workspaceDir)
            if (jobDir.exists()) {
                jobDir.eachDirRecurse { dir ->
                    def requestFile = new File(dir, ultraSimpleSqlConfig.requestFileName)
                    if (requestFile.exists()) {
                        requestFiles.add("    gradle generateSqlAgent -Pfile=${dir.path - rootDir.path - '/'}/request.md")
                    }
                }
            }
            
            if (requestFiles) {
                requestFiles.each { println it }
            } else {
                println "    (暂无可用的request.md文件)"
            }
            return
        }
        
        def requestFile = file(requestPath)
        if (!requestFile.exists()) {
            throw new GradleException("❌ 文件不存在: ${requestPath}")
        }
        
        def domainName = requestFile.parentFile.name
        def domainPath = requestFile.parentFile
        
        def promptText = """
请基于 ${ultraSimpleSqlConfig.rulesFile} 规则处理以下输入文件，生成 Flink SQL 和 Kafka 测试数据。

输入文件: ${requestPath}

输出要求:
1. SQL文件: ${domainPath}/${ultraSimpleSqlConfig.outputSqlDir}/${domainName}_ultra.sql
2. 测试数据: ${domainPath}/${ultraSimpleSqlConfig.outputTestDir}/kafka-test-data.md

请直接开始处理，无需确认。
"""
        
        println """
        🚀 Cursor Agent完全自动化执行模式 (Beta)
        
        📁 业务域: ${domainName}
        📄 输入文件: ${requestPath}
        🤖 正在启动Cursor Agent...
        """
        
        // 使用最稳定的Cursor Agent集成方案
        try {
            def cursorAgentPath = ultraSimpleSqlConfig.cursorAgentPath
            
            // 检查cursor-agent是否可用
            def checkProcess = new ProcessBuilder(["which", cursorAgentPath]).start()
            if (checkProcess.waitFor() != 0) {
                throw new GradleException("❌ Cursor Agent CLI 不可用。请先安装: curl https://cursor.com/install -fsS | bash")
            }
            
            println "🚀 使用Cursor Agent智能启动模式..."
            
            // 复制提示词到剪贴板
            def clipboardProcess = new ProcessBuilder(["pbcopy"]).start()
            clipboardProcess.outputStream.write(promptText.bytes)
            clipboardProcess.outputStream.close()
            clipboardProcess.waitFor()
            
            // 启动cursor-agent交互式模式
            println """
            ✅ Cursor Agent智能启动完成！
            
            📋 提示词已复制到剪贴板
            🤖 正在启动Cursor Agent交互界面...
            
            💡 在Cursor Agent界面中操作:
            1️⃣ 等待界面完全加载
            2️⃣ 按 Cmd+V 粘贴提示词
            3️⃣ 按 Enter 开始执行
            
            📄 生成完成后，文件将保存到:
            • SQL文件: ${domainPath}/${ultraSimpleSqlConfig.outputSqlDir}/${domainName}_ultra.sql
            • 测试数据: ${domainPath}/${ultraSimpleSqlConfig.outputTestDir}/kafka-test-data.md
            
            ⏱️ 预计完成时间: 30-60秒
            """
            
            // 启动cursor-agent (不等待，让用户手动操作)
            def agentProcess = new ProcessBuilder([cursorAgentPath])
                .directory(rootDir)
                .start()
            
            // 给一点时间让agent启动
            Thread.sleep(2000)
            
            println """
            🎯 Cursor Agent已启动！请在界面中粘贴并执行提示词。
            
            💡 小贴士:
            • 如果界面没有自动弹出，请检查任务栏或浏览器
            • 执行完成后可以继续在Agent中进行对话和调整
            • 生成的文件会自动保存到指定位置
            """
            
        } catch (Exception e) {
            println """
            ❌ Cursor Agent启动失败: ${e.message}
            
            💡 回退方案: 使用 gradle generateSqlAuto 进行半自动化操作
            """
        }
    }
}

// 2. 创建新业务域
task createDomain {
    group FLINK_SQL_TASK_GROUP
    description '为新业务域创建标准化目录结构和request.md模板'
    
    doLast {
        def domainName = project.findProperty('domain') ?: 'new-domain'
        def domainDir = "${ultraSimpleSqlConfig.workspaceDir}/${domainName}"
        
        println "🏗️ 创建业务域: ${domainName}"
        
        // 创建标准目录结构
        [
            "${domainDir}/${ultraSimpleSqlConfig.outputSqlDir}",
            "${domainDir}/${ultraSimpleSqlConfig.outputTestDir}",
            "${domainDir}/${ultraSimpleSqlConfig.outputDocsDir}"
        ].each { dir ->
            mkdir dir
        }
        
        // 创建request.md模板文件
        def requestFile = file("${domainDir}/request.md")
        if (!requestFile.exists()) {
            def templateContent = """# ${domainName} 极简版Flink SQL需求

## 📊 ER图定义

```plantuml
@startuml
!theme plain
skinparam linetype ortho

' 源表定义 (Kafka)
entity "BusinessEvent" as be <<source>> {
  * domain : string <<业务域>>
  * type : string <<事件类型>>
  * payload : string <<业务载荷JSON>>
  * event_time : timestamp <<事件时间>>
  --
  table_type: source
  domain: ${domainName}
  topic: ${domainName}-events
}

' 维表定义 (MySQL + TTL) - 根据实际需要添加
entity "dim_example" as dim <<dimension>> {
  * id : string <<主键>> <<PK>>
  * name : string <<名称>>
  --
  table_type: dimension
  connector: mysql + ttl(30min)
}

' 关联关系
be ||--o{ dim : "payload.example_id = id"

note right of be : "Kafka源表\\n自动配置topic"
note right of dim : "MySQL维表\\n自动配置TTL缓存"
note bottom : "结果表通过字段映射配置定义"

@enduml
```

## 🔄 字段映射定义

```yaml
# 结果表配置
result_table:
  table_name: "dwd_${domainName}_wide"
  table_type: "result"
  connector: "odps"
  primary_key: ["id"]

# 字段映射配置
field_mapping:
  # 基础字段映射
  id: "payload.id"
  user_id: "payload.userId"
  
  # 维表字段映射
  example_name: "dim_example.name"
  
  # 计算字段
  status_desc: "CASE payload.status WHEN 1 THEN '有效' WHEN 0 THEN '无效' ELSE '未知' END"
  
  # 时间字段转换
  create_time: "TO_TIMESTAMP_LTZ(payload.createTime, 0)"
  
  # 智能指标字段 (AI自动生成SQL)
  user_activity_score: "根据用户活动频率和交互质量计算用户活跃度分数"
  business_impact_level: "基于业务指标和用户行为分析业务影响等级"
```
"""
            requestFile.text = templateContent
        }
        
        println """
        ✅ 业务域创建完成！
        
        📁 目录结构:
        ${domainDir}/
        ├── sql/                # SQL文件输出目录
        ├── test/               # 测试数据输出目录
        ├── docs/               # 文档输出目录
        └── request.md          # 极简版需求文件
        
        📝 下一步:
        1. 编辑 ${requestFile.absolutePath}
        2. 完善PlantUML ER图和字段映射
        3. 运行 gradle generateSql -Pfile=${domainDir}/request.md
        """
    }
}

// 3. 列出可用的request文件
task listRequests {
    group FLINK_SQL_TASK_GROUP
    description '列出所有可用的request.md文件'
    
    doLast {
        def requestFiles = fileTree(ultraSimpleSqlConfig.workspaceDir) {
            include '**/request.md'
        }
        
        println """
        📋 可用的request文件:
        ================================
        """
        
        if (requestFiles.isEmpty()) {
            println "❌ 未找到任何request.md文件"
            println """
            
            💡 创建新的业务域:
            gradle createDomain -Pdomain=your-domain-name
            """
        } else {
            requestFiles.each { file ->
                def relativePath = rootProject.relativePath(file)
                def domainName = file.parentFile.name
                println "📁 ${domainName}: ${relativePath}"
            }
            
            println """
            
            💡 使用方法:
            gradle generateSql -Pfile=job/domain-name/request.md
            """
        }
    }
}

// 3.1. 测试任务: 调试AppleScript自动化
task testCursorAutomation {
    group FLINK_SQL_TASK_GROUP
    description '测试Cursor CLI + AppleScript自动化功能'
    
    doLast {
        def testPrompt = "测试提示词：请生成一个简单的SQL查询"
        
        println "🧪 测试Cursor自动化功能..."
        
        if (System.getProperty("os.name").toLowerCase().contains("mac")) {
            try {
                def cursorCliPath = ultraSimpleSqlConfig.cursorCliPath
                def cursorCli = file(cursorCliPath)
                
                if (cursorCli.exists()) {
                    println "1️⃣ 使用Cursor CLI打开项目..."
                    def cursorProcess = new ProcessBuilder([cursorCliPath, "."]).start()
                    cursorProcess.waitFor()
                    
                    println "2️⃣ 复制测试提示词到剪贴板..."
                    def clipboardProcess = new ProcessBuilder(["pbcopy"]).start()
                    clipboardProcess.outputStream.write(testPrompt.bytes)
                    clipboardProcess.outputStream.close()
                    clipboardProcess.waitFor()
                    
                    println "3️⃣ 等待Cursor启动..."
                    Thread.sleep(3000)
                    
                    println "4️⃣ 执行AppleScript自动化..."
                    def appleScript = """
                    tell application "Cursor"
                        activate
                    end tell
                    
                    delay 2
                    
                    tell application "System Events"
                        keystroke "k" using {command down, shift down}
                        delay 3
                        keystroke "v" using {command down}
                        delay 1
                        key code 36
                    end tell
                    """.stripIndent()
                    
                    def tempScript = File.createTempFile("test_cursor", ".scpt")
                    tempScript.text = appleScript
                    
                    def scriptProcess = new ProcessBuilder(["osascript", tempScript.absolutePath])
                        .redirectErrorStream(true)
                        .start()
                    
                    def output = scriptProcess.inputStream.text
                    def exitCode = scriptProcess.waitFor()
                    
                    tempScript.delete()
                    
                    if (exitCode == 0) {
                        println "✅ AppleScript自动化测试成功！"
                    } else {
                        println "❌ AppleScript执行失败，退出码: ${exitCode}"
                        println "错误输出: ${output}"
                    }
                } else {
                    println "❌ Cursor CLI不可用"
                }
            } catch (Exception e) {
                println "❌ 测试失败: ${e.message}"
                e.printStackTrace()
            }
        } else {
            println "⚠️ 此功能仅支持macOS"
        }
    }
}

// 4. Cursor CLI检查和设置任务
task setupCursorCli {
    group FLINK_SQL_TASK_GROUP
    description '检查和设置Cursor CLI路径'
    
    doLast {
        def cursorCliPath = ultraSimpleSqlConfig.cursorCliPath
        def cursorCli = file(cursorCliPath)
        
        println """
        🔍 Cursor CLI环境检查
        ===================================
        """
        
        println "📍 配置路径: ${cursorCliPath}"
        println "   存在: ${cursorCli.exists() ? '✅' : '❌'}"
        
        if (cursorCli.exists()) {
            try {
                def process = new ProcessBuilder([cursorCliPath, "--version"])
                    .redirectOutput(ProcessBuilder.Redirect.PIPE)
                    .start()
                def version = process.inputStream.text.trim()
                process.waitFor()
                
                println "   版本: ${version}"
                println """
                ✅ Cursor CLI 可用！
                
                💡 使用方法:
                gradle generateSqlAuto -Pfile=job/domain/request.md
                """
            } catch (Exception e) {
                println "   错误: ${e.message}"
            }
        } else {
            println """
            ❌ Cursor CLI 不可用
            
            💡 解决方法:
            1. 确保已安装 Cursor.app
            2. 检查安装路径是否为: ${cursorCliPath}
            3. 如果路径不同，请修改 build.gradle 中的 cursorCliPath 配置
            
            🔧 其他可能的路径:
            - /usr/local/bin/cursor
            - /opt/homebrew/bin/cursor
            - ~/.cursor/cursor
            """
        }
        
        // 尝试查找其他可能的Cursor CLI路径
        def alternativePaths = [
            "/usr/local/bin/cursor",
            "/opt/homebrew/bin/cursor",
            "~/.cursor/cursor",
            "/Applications/Cursor.app/Contents/MacOS/Cursor"
        ]
        
        def foundAlternatives = []
        alternativePaths.each { path ->
            def expandedPath = path.startsWith("~") ? 
                path.replace("~", System.getProperty("user.home")) : path
            if (file(expandedPath).exists()) {
                foundAlternatives.add(expandedPath)
            }
        }
        
        if (foundAlternatives.size() > 0) {
            println """
            
            🔍 发现其他Cursor CLI路径:
            ${foundAlternatives.collect { "   - ${it}" }.join('\n')}
            """
        }
        
        println "==================================="
    }
}

// 5. 环境检查任务
task checkEnvironment {
    group FLINK_SQL_TASK_GROUP
    description '检查极简版SQL生成器环境'
    
    doLast {
        println """
        🔍 极简版Flink SQL生成器环境检查
        ===================================================
        """
        
        // 检查工作空间
        def workspaceDir = file(ultraSimpleSqlConfig.workspaceDir)
        println "📁 工作空间: ${workspaceDir.absolutePath}"
        println "   存在: ${workspaceDir.exists() ? '✅' : '❌'}"
        
        // 检查规则文件
        def rulesFile = file(ultraSimpleSqlConfig.rulesFile)
        println "📋 规则文件: ${rulesFile.absolutePath}"
        println "   存在: ${rulesFile.exists() ? '✅' : '❌'}"
        
        // 检查模板文件
        def templateFile = file(ultraSimpleSqlConfig.templateFile)
        println "📄 模板文件: ${templateFile.absolutePath}"
        println "   存在: ${templateFile.exists() ? '✅' : '❌'}"
        
        // 检查request文件
        if (workspaceDir.exists()) {
            def requestFiles = fileTree(workspaceDir) {
                include '**/request.md'
            }
            println "📝 Request文件: ${requestFiles.files.size()}个"
            requestFiles.each { file ->
                def relativePath = rootProject.relativePath(file)
                println "   - ${relativePath}"
            }
        }
        
        println """
        ===================================================
        
        💡 使用指南:
        1. gradle createDomain -Pdomain=domain-name  # 创建新业务域
        2. gradle listRequests                       # 列出所有request文件
        3. gradle generateSql -Pfile=path/to/request.md  # 生成SQL
        4. gradle help                               # 查看所有任务
        
        🤖 AI执行方式:
        - 当前需要在Cursor IDE中手动执行AI规则
        - 规则文件: ${ultraSimpleSqlConfig.rulesFile}
        """
    }
}

// 5. 帮助任务
task sqlHelp {
    group FLINK_SQL_TASK_GROUP
    description '显示极简版Flink SQL生成器使用帮助'
    
    doLast {
        println """
        
        🚀 极简版Flink SQL生成器使用指南
        ===============================================
        
        📋 主要任务:
        ├── generateSql      - 生成Flink SQL和测试数据 (复制到剪贴板)
        ├── generateSqlAuto  - 自动在Cursor中执行生成 (使用Cursor CLI)
        ├── createDomain     - 创建新业务域
        ├── listRequests     - 列出所有request文件
        ├── setupCursorCli   - 检查和设置Cursor CLI环境
        ├── checkEnvironment - 检查环境配置
        └── sqlHelp          - 显示本帮助信息
        
        🎯 使用流程:
        
        1️⃣ 创建新业务域:
           gradle createDomain -Pdomain=your-domain-name
        
        2️⃣ 编辑request.md文件:
           - 设计PlantUML ER图 (仅源表/维表)
           - 配置结果表和字段映射
           - 添加智能指标描述
        
        3️⃣ 生成Flink SQL:
           gradle generateSql -Pfile=job/your-domain/request.md      # 复制到剪贴板
           gradle generateSqlAuto -Pfile=job/your-domain/request.md   # 半自动化 (推荐)
           gradle generateSqlAgent -Pfile=job/your-domain/request.md  # 完全自动化 (Beta)
        
        4️⃣ AI执行选项:
           - generateSql: 提示词复制到剪贴板，手动在Cursor中执行
           - generateSqlAuto: 智能集成，自动打开Cursor+复制提示词 (仅需2步)
           - generateSqlAgent: 完全自动化，无需手动操作 (Beta，需Cursor Agent CLI)
           
        🔧 环境设置:
           gradle setupCursorCli  # 检查Cursor CLI是否可用
        
        ⚡ 快速示例:
        gradle createDomain -Pdomain=user-analytics
        gradle generateSql -Pfile=job/user-analytics/request.md
        
        📚 更多信息:
        - 规则文件: ${ultraSimpleSqlConfig.rulesFile}
        - 模板文件: ${ultraSimpleSqlConfig.templateFile}
        - 输出目录: 自动在对应业务域下创建
        
        ===============================================
        """
    }
}

publishing {
    publications {
        maven(MavenPublication) {
            from components.java
        }
    }
}